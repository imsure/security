/* Generated by CIL v. 1.7.0 */
/* print_CIL_Input is false */

struct t___0;
struct t___9;
struct t___23;
extern void signal(int sig , void *func ) ;
extern float strtof(char const   *str , char const   *endptr ) ;
int o___7  =    0;
typedef struct t___0 o___8;
struct t___9 {
  int f___10 ;
  struct t___9 *f___11 ;
};
extern double strtod(char const   *str , char const   *endptr ) ;
extern int fclose(void *stream ) ;
extern void *fopen(char const   *filename , char const   *mode ) ;
extern void abort() ;
extern void exit(int status ) ;
extern int raise(int sig ) ;
extern int fprintf(struct t___0 *stream , char const   *format  , ...) ;
struct t___9 *o___12  =    (struct t___9 *)0;
extern int rand() ;
extern unsigned long strtoul(char const   *str , char const   *endptr , int base ) ;
void o___13(unsigned long *l___692 ) ;
void o___14(unsigned long (*l___694)[2] , unsigned long *l___695 ) ;
void o___15(unsigned long *l___697 ) ;
void o___16(void) ;
void o___17(unsigned long *l___699 ) ;
extern int strncmp(char const   *s1 , char const   *s2 , unsigned long maxlen ) ;
void o___18(unsigned long *l___701 , unsigned long *l___702 ) ;
int o___19[30]  = 
  {      288,      607,      3,      403, 
	 33,      5,      448,      488, 
	 5,      188,      614,      7, 
	 188,      523,      65,      208, 
	 474,      45,      348,      26, 
	 72,      243,      306,      23, 
	 238,      103,      89,      403, 
	 404};
extern int gettimeofday(struct t___23 *tv , void *tz  , ...) ;
extern int printf(char const   *format  , ...) ;
int main(int l___678 , char **l___679 ) ;
extern unsigned long strlen(char const   *s ) ;
struct t___9 *o___20  =    (struct t___9 *)0;
void o___21(void) ;
extern long strtol(char const   *str , char const   *endptr , int base ) ;
typedef struct t___9 *o___22;
extern unsigned long strnlen(char const   *s , unsigned long maxlen ) ;
extern void *memcpy(void *s1 , void const   *s2 , unsigned long size ) ;
struct t___23 {
  long f___24 ;
  long f___25 ;
};
extern void *malloc(unsigned long size ) ;
extern int scanf(char const   *format  , ...) ;
int main(int argc , char **argv ) 
{ 
  unsigned long l___681[1] ;
  unsigned long l___682[1] ;
  int l___683 ;
  unsigned long l___684 ;
  int l___685 ;
  int l___686 ;
  int l___687 ;
  struct t___9 *l___688 ;

  {
    /* This piece of code is useless. The main point is to
       give o___20 a non-null address. o___20 itself is a
       ciruclar linked list. */
    l___686 = 0;
    while (l___686 < 2) {
      l___687 = rand();
      {
	l___688 = (struct t___9 *)malloc(16UL);
	if (l___688 != (struct t___9 *)0UL) {
	  l___688->f___10 = l___687;
	  if (o___20 != (struct t___9 *)0UL) {
	    l___688->f___11 = o___20->f___11;
	    o___20->f___11 = l___688;
	  } else {
	    l___688->f___11 = l___688;
	    o___20 = l___688;
	  }
	} else {

	}
      }
      l___686 ++;
    }
    // o___20 is a cirular linked list with 2 elements.
    // 1804289383, 846930886
    o___12 = o___20;
    o___7 = (int )((unsigned long )argv) * o___7;
    o___7 = argc ^ o___7;   // o___7 is always 2
    printf("o___12->f___10 = %d\n", o___12->f___10);
    printf("o___12->f___11->f___10 = %d\n", o___12->f___11->f___10);
    printf("o___7 = %d\n", o___7);
    //o___21();
    if (argc != 2) {
      printf("Call this program with %i arguments\n", 1);
      exit(-1);
    }
    /* Convert input string to a unsigned long. */
    l___683 = 0;
    while (l___683 < 1) {
      l___684 = strtoul((char const   *)*(argv + (l___683 + 1)), (char const   *)0,
			10);
      l___681[l___683] = l___684; // l___681 is the converted unsigned long from input
      l___683 ++;
    }
    o___7 = l___683 + o___7; // l___683 = 1, o___7 = 1 + 2 = 3
    printf("o___7 = %d\n", o___7);
    o___7 = (int )l___684 << o___7; // << 3 is like * 8
    printf("o___7 = %d\n", o___7); // o___7 = argv[1] * 8

    // l___681 is the actually the input integer value
    printf("l___681[0](converted from input) = %lu\n", l___681[0]);
    o___18((unsigned long *)(l___681), (unsigned long *)(l___682));
    l___685 = 0;
    while (l___685 < 1) {
      printf("%lu\n", l___682[l___685]);
      l___685 ++;
    }
    o___7 = l___685 & o___7;
    return (0);
  }
}
void o___16(void) 
{ 


  {

  }
}

// always fill 33 to l___699
void o___17(unsigned long *l___699 ) 
{ 
  {
    // 2147483647 = 0x7fffffff
    // o___19[5] = 5, o___19[2] = 3
    if (o___19[((o___7 & 2147483647) % 10) * 3] % o___19[5] == o___19[2]) { // this is always true.
      *l___699 = 33;
    } else {
      *l___699 = 29;
    }
  }
  printf("*l___699 = %lu\n", *l___699);
}
/*It takes the input integer value, transform it to another value.
  first arg: input number, 2nd arg: returned value. Both are array
  with one element. */
void o___18(unsigned long *input , unsigned long *output ) 
{ 
  unsigned long l___704[2] ;
  unsigned int l___705 ;
  int l___706 ;
  unsigned long l___707 ;

  {
    l___707 = 34;
    while (1) {
      switch (l___707) {
      case 34: ;
	o___17(& l___707);// l___707 = 33, falls to case 33.
	break;
      case 33: ;
	o___15(& l___707); // l___707 = 31, goto case 31
	break;
      case 32: 
	o___21();
	l___707 = 30;
	break;
      case 31: ;
	l___707 = 30;
	break;
      case 30: // only executed once. should out of loop.
	l___704[0UL] = *(input + 0UL) & 680373089UL; // get an small value compared to l___704[1UL]. at most 680373089UL
	printf("l___704[0UL]=%lu\n", l___704[0UL]);
	l___707 = 3;
	break;
      case 29: ;
	l___707 = 28;
	break;
      case 28: ;// exectued only once
	o___14(& l___704, & l___707); // l___704 holds two transformed value of input, l___707=28
	break;
      case 27: ;
	o___13(& l___707);
	break;
      case 26: 
	l___706 = main(6, 0);
	l___707 = 24;
	break;
      case 25: ;
	l___707 = 24;
	break;
      case 24: 
	l___704[1UL] |= ((l___704[1UL] >> (((l___704[1UL] >> 1UL) & 7UL) | 1UL)) & 31UL) << 4UL;
	l___707 = 2;
	break;
      case 23: ;
	if (l___704[0UL] <= l___704[1UL]) { // true
	  l___707 = 22;
	} else {
	  l___707 = 14;
	}
	break;
      case 22: ;
	if (o___12 == (struct t___9 *)0UL) {
	  l___707 = 21;
	} else { // true
	  l___707 = 20;
	}
	break;
      case 21: ;
	l___707 = 15;
	break;
      case 20: ;
	if (o___12 == (struct t___9 *)0UL) {
	  l___707 = 19;
	} else { // true
	  l___707 = 18;
	}
	break;
      case 19: ;
	l___707 = 15;
	break;
      case 18: ;
	if (o___19[((o___7 & 2147483647) % 10) * 3] % o___19[5] != o___19[2]) { 
	  l___707 = 17;
	} else { // true
	  l___707 = 16;
	}
	break;
      case 17: 
	o___18(0, 0);
	l___707 = 15;
	break;
      case 16: ;
	l___707 = 15;
	break;
      case 15: 
	l___704[1UL] /= 2UL;
	printf("in case 15, l___704[1UL]=%lu\n", l___704[1UL]);
	l___707 = 7;
	break;
      case 14: ;
	if (o___20 != (struct t___9 *)0UL) {
	  l___707 = 13;
	} else {
	  l___707 = 8;
	}
	break;
      case 13: ;
	if (o___20 != (struct t___9 *)0UL) {
	  l___707 = 12;
	} else {
	  l___707 = 11;
	}
	break;
      case 12: 
	l___704[1UL] = (l___704[0UL] >> (((l___704[0UL] >> 4UL) & 15UL) | 1UL)) | (l___704[0UL] << (64UL - (((l___704[0UL] >> 4UL) & 15UL) | 1UL)));
	l___707 = 7;
	break;
      case 11: ;
	if (o___12 == (struct t___9 *)0UL) {
	  l___707 = 10;
	} else {
	  l___707 = 9;
	}
	break;
      case 10: 
	l___704[1UL] = ((l___704[0UL] >> (((l___704[0UL] >> 4UL) & 15UL) | 1UL)) | (l___704[0UL] << (64UL - (((l___704[0UL] >> 4UL) & 15UL) | 1UL)))) >> 9;
	l___707 = 7;
	break;
      case 9: 
	l___704[1UL] = ((l___704[0UL] >> (((l___704[0UL] >> 4UL) & 15UL) | 1UL)) | (l___704[0UL] << (64UL - (((l___704[0UL] >> 4UL) & 15UL) | 1UL)))) >> 9;
	l___707 = 7;
	break;
      case 8: 
	l___704[1UL] = 2UL;
	l___707 = 7;
	break;
      case 7: ;
	if (o___19[((o___7 & 2147483647) % 10) * 3] % o___19[5] != o___19[2]) {
	  l___707 = 6;
	} else { // true
	  l___707 = 5;
	}
	break;
      case 6: ;
	l___707 = 4;
	break;
      case 5: 
	*(output + 0UL) = ((l___704[0UL] + l___704[1UL]) << 7UL) | ((l___704[0UL] + l___704[1UL]) >> 57UL);
	printf("output=%lu\n", *output);
	l___707 = 4;
	break;
      case 4: ;
	return;
	break;
      case 3: // only executed once. should out of loop.
	l___704[1UL] = *(input + 0UL) + 282530747185134996UL; // big value!
	printf("l___704[1UL]=%lu\n", l___704[1UL]);
	l___707 = 28;
	break;
      case 2: 
	l___705 = *((unsigned int *)(& l___704[0UL]) + 1);
	l___707 = 1;
	break;
      case 1: 
	*((unsigned int *)(& l___704[0UL]) + 1) = *((unsigned int *)(& l___704[0UL]) + 0);
	l___707 = 0;
	break;
      case 0: 
	*((unsigned int *)(& l___704[0UL]) + 0) = l___705;
	l___707 = 23;
	break;
      }
    }
  }
}
void o___21(void) 
{ 


  {
    return;
  }
}

// always return 31
void o___15(unsigned long *l___697 ) 
{ 
  {
    if (o___19[((o___7 & 2147483647) % 10) * 3 + 1] % o___19[11] != o___19[5]) { // alwasys false
      *l___697 = 32;
    } else {
      *l___697 = 31;
    }
  }
  printf("*l___697 = %lu\n", *l___697);
}
void o___13(unsigned long *l___692 ) 
{ 


  {
    if (o___19[((o___7 & 2147483647) % 10) * 3 + 1] % o___19[11] != o___19[5]) {
      *l___692 = 26;
    } else {
      *l___692 = 25;
    }
  }
}

// always return 23
void o___14(unsigned long (*l___694)[2] , unsigned long *l___695 ) 
{ 
  {
    if ((*l___694)[0UL] > (*l___694)[1UL]) {
      *l___695 = 27;
    } else {
      *l___695 = 23;
    }
  }
  printf("%s: l___695=%lu\n", __func__, *l___695);
}
